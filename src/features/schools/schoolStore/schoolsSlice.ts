import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../../../app/store";
import { fetchData } from "./schoolsAPI";
import { ISchoolData, ISchoolDetails } from "../Interfaces/ISchoolData";

export interface CounterState {
  fullData: ISchoolData;
  filteredSchools: ISchoolData;
  selectedSchoolDetails: ISchoolDetails;
  countries: string[];
  selectedCountry: string;
  camps: string[];
  selectedCamp: string;
  schools: string[];
  selectedSchool: string;
  status: "idle" | "loading" | "succeeded" | "failed";
}

const initialState: CounterState = {
  fullData: {} as ISchoolData,
  filteredSchools: {} as ISchoolData,
  selectedSchoolDetails: {} as ISchoolDetails,
  countries: [],
  selectedCountry: "",
  camps: [],
  selectedCamp: "",
  schools: [],
  selectedSchool: "",
  status: "idle",
};

export const getDataAsync = createAsyncThunk("schools/fetchData", async () => {
  const response = await fetchData();
  // The value we return becomes the `fulfilled` action payload
  return response.data;
});

export const schoolsSlice = createSlice({
  name: "schools",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    selectCountry: (state, action: PayloadAction<string>) => {
      return {
        ...state,
        selectedCountry: action.payload,
      };
    },
    selectCamp: (state, action: PayloadAction<string>) => {
      return {
        ...state,
        selectedCamp: action.payload,
      };
    },
    selectSchool: (state, action: PayloadAction<string>) => {
      return {
        ...state,
        selectedSchool: action.payload,
      };
    },
    putSchool: (state, action: PayloadAction<ISchoolDetails>) => {
      return {
        ...state,
        selectedSchoolDetails: action.payload,
      };
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getDataAsync.pending, (state) => {
        return {
          ...state,
          status: "loading",
        };
      })
      .addCase(getDataAsync.fulfilled, (state, action) => {
        //state.status = "idle";
        var data: ISchoolDetails[] = action.payload.map(function (item) {
          return item;
        });

        var fullData = {} as ISchoolData;
        fullData.schools = data as ISchoolDetails[];
        let countries = new Set<string>();
        let camps = new Set<string>();
        let schools = new Set<string>();

        fullData.schools.forEach((school: ISchoolDetails) => {
          if (!countries.has(school.country)) countries.add(school.country);
          if (!camps.has(school.camp)) camps.add(school.camp);
          if (!schools.has(school.school)) schools.add(school.school);
        });

        var countriesArray = Array.from(countries);
        var campsArray = Array.from(camps);
        var schoolsArray = ["All"].concat(Array.from(schools));

        let filteredSchoolsData: ISchoolDetails[] = [];
        fullData.schools.forEach((school: ISchoolDetails) => {
          if (
            school.country == countriesArray[0] &&
            school.camp == campsArray[0]
          )
            filteredSchoolsData.push(school);
        });
        var filteredSchools = {} as ISchoolData;
        filteredSchools.schools = filteredSchoolsData;
        return {
          ...state,
          status: "succeeded",
          fullData: fullData,
          countries: countriesArray,
          selectedCountry: countriesArray.length > 0 ? countriesArray[0] : "",
          camps: campsArray,
          selectedCamp: campsArray.length > 0 ? campsArray[0] : "",
          schools: schoolsArray,
          selectedSchool: schoolsArray[0],
          filteredSchools: filteredSchools,
        };
      });
  },
});

export const { selectCountry, selectCamp, selectSchool, putSchool } =
  schoolsSlice.actions;

export const selectData = (state: RootState) => state.schools;

export default schoolsSlice.reducer;
